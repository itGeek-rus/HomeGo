package main

import "fmt"

//Задача 1
//Результатом будет замена второго значения slice "a", то есть "b" заменится на "q"
//Исходный slice будет выглядеть следующим образом: [a q c]

func main() {
	a := []string{"a", "b", "c"}
	b := a[1:2]
	b[0] = "q"
	fmt.Println(a)
}

//Задача 2
//Код выводит следущее: func "mod" - [5 5 5 5 5 5] func main - [1 2 3 4 5]
//Изначальнео "sl" имеет длину 5 и емкость 5, при вызове функции "append(a, 125)" внутри функции "mod" Go создает новый базовый массив, происходит копирование старых элементов
//и добавляет новый. Теперь slice "a" ссылается на новый массив, а исходный "sl" в функции "main" не меняется

//Цикл внутри функции "mod" меняет все slice "a" на "5", но поскльку после функции "append" slice "a" ссылается на новый массив,
//изменений в slice "sl" не происходят

//Итого: функция "mod" печатает измененный slice [5 5 5 5 5 5], slice "sl" в функции "main" остается неизменным, так как
//функция "append" создала новый массив, а исходный slice "sl" не изменился

func main() {
	sl := []int{1, 2, 3, 4, 5}
	mod(sl)
	fmt.Println(sl)
}

func mod(a []int) {
	a = append(a, 125)
	for i := range a {
		a[i] = 5
	}
	fmt.Println(a)
}

//Задача 3
//Код выводит следущее: func "mod" - [5 5 5 5] func "main" - [5 5 5 5]
//Цикл в функции "mod" меняет все значения слайса "a" на значение "5", но так как используется один и тот же базовый массив, изменения происходят и в slice "sl"
//то есть оба slice работают с одним и тем же базовым массивом
func mod(a []int) {
	for i := range a {
		a[i] = 5
	}
	fmt.Println(a)
}

func main() {
	sl := make([]int, 4, 8)
	sl[0] = 1
	sl[1] = 2
	sl[2] = 3
	sl[3] = 5
	mod(sl)
	fmt.Println(sl)
}
